---
layout: post
title: Pharo Syntax notes
categories: [reading notes]
tags: [pharo, smalltalk, blocks, closures, objects, messages, classes]
---

<p>Notes are heavily bases on <a href="https://books.pharo.org/learning-oop/" target="_blank">Learning Object-Oriented Programming, Design and TDD with Pharo</a></p>

<p>Pharo is a pure object-oriented language based on Smalltalk, the original object-oriented language developed by Alan Kay in the 1970s.</p>

<h2>Key facts about Pharo</h2>

<ul>
  <li>The syntax of Pharo can fit on a single postcard. The sytax and language model is explained in <a href="http://files.pharo.org/media/pharoCheatSheet.pdf" target="_blank">two pages.</a></li>
  <li>The language is based on <strong>objects</strong>, <strong>messages</strong> and <strong>closures.</strong></li>
  <li>Closures are a central conerstone of the language which are the foundation for conditional statements and loops.</li>
</ul>

<h2>Messages</h2>

<p>Message syntax in Pharo is minimalist, but are central to all computations in Pharo. There are three kinds of messages: unary, binary and keyword-based messages.</p>

<p>In Pharo, messages are sent to a reciever, which is always to the left of the message. You can send different messages by using different message names (known as <em>selectors</em>.</p>

<code class="lang-smalltalk">'hello' reversed</code>

<p>In the code sample above, the message 'reversed' is sent to a reciever, which is a string object containing the characters 'hello'. The output of this message sending is a new string with the same characters in reverse order.</p>

<h3>Unary messages</h3>

<p>Unary messages involve only one object (their reciever), and do not take any arguments.</p>

<h3>Keyword messages</h3>

<p>Keyword messages pass arguments to the reciever.</p>

<code class="lang-smalltalk">'hello' at: 2</code>

<p>The above keyword message sends the message 'at:' to the reciever string object along with an argument, which is an integer object. The reciever object then returns the character object at position 2.</p>

<p>Keyword messages end with a colon to signify that it should be followed by an argument.</p>

<p>Keyword messages can pass more than one argument. A single message can have as many colon terminated keywords as necessary, each followed by an argument.</p>

<code class="lang-smalltalk">'hello' copyFrom: 1 to: 3</code>

<p>In the example above, the keyword message is 'copyFrom: to:'. The output of the code is the first three characters of the reciever string object.</p>

<h3>Binary Messages</h3>

<p>Binary messages can only be composed of symbols. They only expect a single argument, even though they do not end in a colon.</p>

<code class="lang-smalltalk">1 + 2</code>

<p>The main use of binary messages is for arithmetic operations like in the example above where we have sent the message '+' to an integer with '2' as an argument. The code above returns an integer object with the value of 3.</p>

<code class="lang-smalltalk">'Hello' , ' World!'</code>

<p>There are some examples outside of arithmetic operations that use binary messages. In the example above, we sent the ',' message with the argument ' World!' to the reciever string object. The ',' message represents a string cocatenation message.</p>

<h3>Order of message execution</h3>

<p>Unary >> Binary >> Keyword</p>

<h3>Sending multiple messages to the same object</h3>

<p>To send multiple messages to the same object in quick succession, we can group messages into a <em>message cascade</em>, which are seperated with semi-colons. When we do this, we only state the reciever once at the beginning of the cascade.</p>

<pre>
<code class="lang-smalltalk">
| aStream |
aStream := (String new: 100) writeStream.
aStream
  nextPutAll: 'Today, ';
  nextPutAll: Date today printString;
  contents
</code>
</pre>

<p>In the example above we have created a variable called 'aStream' which is assigned a new String object that is passed a message selector called 'writeStream'. Then we send the 'aStream' reciever a series of three messages. The first two messages are keyword messages 'nextPutAll:', 'nextPutAll:' and a unary message 'contents'. The output of this cascade of messages is 'Today, 28 January 2017'.</p>

<p>The cascade as a whole returns the value of it's last message. If the last message you send to the reciever is a selector called 'yourself', then it will return the object the messages were sent to. This is necessary when assigning elements to an array so that you get the array back and not just the last element that was assigned to it.</p>

<h2>Objects / Classes</h2>

<p>In Pharo, everything is an object and computation happens by sending messages to objects. Objects are created by sending messages to particular objects named classes, which define the structure and behaviour of the objects they create, also known as their instances.</p>

<p>We can create a new object by sending a message to the class itself.</p>

<code class="lang-smalltalk">String new</code>

<p>In the example above, we are creating a new string object by sending the unary message 'new' to the reciever which is a 'String' class.</p>

<h4>Literal Objects</h4>

<p>Some objects can be expressed directly in the code without having to use the 'new' message.</p>

<code class="lang-smalltalk">#(1 2 3)</code>

<p>In the example above, we have created an Array object containing three integer objects '1, 2' and '3'.</p>

<h2>Variables</h2>

<p>Variables are declared by writing their names between two pipe lines.</p>

<pre>
<code class="lang-smalltalk">
  | myKittensNameIs |
  myKittensNameIs := 'Berry'.
</code>
</pre>

<p>Variables can be assigned using the ':=' assignment statement. Statements are seperated by a full-stop, which makes Pharo code look like English sentences.</p>

<p>Writing in progress...</p>
