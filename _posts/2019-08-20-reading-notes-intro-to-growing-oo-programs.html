---
layout: post
title: reading notes -  introduction chapter to growing object-oriented software
---

<p class="note">Reading notes based on <a
href="https://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627"
   target="_blank">Growing Object-Oriented Software, Guided by Tests</a> by
 Steve Freeman and Nat Pryce</p>

<p>Test-driven development challenged the assumptions of the software industry when it was first introduced. Tests used to be thought of as a means to protect users from bugs in the products they were using. Whereas the test-driven approach views tests as a way to help developers better able to understand the needs of their users, as well as to help them produce those features more reliably.</p>

<p>An interesting idea that the authors mentioned as an aside is that Test-driven development can be used to help us explore ideas in projects that are purely research-based, not intended for production. Am interested in exploring this.</p>

<h2>Software Development as a Learning Process</h2>

<p>As software engineers, we are constantly working on projects that have never been seen before. We build custom solutions to a wide variety of problems that reveal nuances as our exposure to the domain increases.</p>

<p>Often, we are working with technologies that we don't fully understand. We learn new principles, languages and tools whilst we are working on the project. A lot of the time, we are applying techniques we have learned to an unfamiliar context. For more complicated systems, often we only see and understand a small part of the entire system as a whole. We have to work with components that interact with other parts of a system that we might not have encountered yet.</p>

<p>From a customer perspective, it's even more difficult because often the development process reveals aspects of their organisation that they might not have had to deeply consider before. Working together to identify solutions that might be different to the solutions everyone initially had in mind is an iterative process, where effortful communication needs to happen on both sides.</p>

<p>Consequently, the entire development process is also a learning process for eeveryone who is involved. There is a huge amount of uncertainty in this process as people learn to understand each other and the domain better.</p>

<p>To cope with all of this uncertainty, we need a process that helps us prepare for unexpected changes.</p>

<h2>Feedback is the fundemental tool</h2>

<p>Iterative feedback loops is essential to helping us to better understand the system and apply the things we have learned back into the system. One strategy is for team members to split their work into <em>time boxes</em>, where they can add new features and get feedback on both the quantity and quality of those features. For each cycle, the team aims to analyze, design, implement and deploy as many features as they can.</p>

<p>The critical part of the feedback loops is actual deployment. Actually deploying something allows the team to check their assumptions against reality, instead of spending weeks or months building features only to find out that they were founded on the wrong assumptions. Regular deployment cycles allow us to quickly identify course corrections and prevent us from building ourselves into corners that are difficult to back out of.</p>

<p>There are many different types of feedback loops that we can adopt in our projects, including (but not limited to):</p>

<ul>
  <li>Pair programming</li>
  <li>Unit tests</li>
  <li>Acceptance tests</li>
  <li>Daily meetings</li>
  <li>Iterations</li>
  <li>Releases</li>
</ul>

<p>These feedback loops can be grouped into inner loops and outer loops. Inner loops focus on the technical details of what the code does and whether it collaborates with other parts of the system as intended. Whereas outer loops focus on the domain and reveal whether the system meets the users needs effectively.</p>

<p>The more feedback loops you have, the more opportunities you are provided with to know that you are on the track, doing the right thing and doing it in an effective way.</p>

<h3>Development using an iterative and incremental approach.</h3>

<p>Iterative development is where you refine your implementation of features based on feedback that you receive from real users.</p>

<p>Incremental development is where a system is built feature by feature. There is always a stable version of the system ready for deployment. Each new feature is integrated fully into the existing system. Instead of making your users wait for a new car that meets all of their current specifications, you can start them with a skateboard so that they have something to get around on. Then you can keep upgrading them until they get a much more personalised car, because they would have had a chance to discover things that would make their experience better in stages of most important.</p>

<h2>Practices that support change</h2>

<p>To reliably cope with unexpected and unavoidable changes in our system, we need two technical foundations: Testing and simplicity.</p>

<p>Testing allows us to build a safety net that tells us the moment when something in our system stops working. This is especially useful when we want to add a new feature without breaking one that already exists in the system <em>(regression errors).</em> We should aim to automate tests as much as possible to reduce costs associated with building, deploying and changing our system</p>

<p>Simplicity means always trying to write code that is easy to read and understand. This means avoiding 'clever' solutions that require effort to understand exactly what it is doing. If there are slight performance gains to the 'clever' solution, these will be lost in the time it takes for your future self and colleagues to decipher the cryptic instructions.</p>

<p>Code that is simple to read is not easy to write. It require a fair amount of time revisiting the system regularly and asking whether anything needs to be regactored in light of new changes. Is there any duplication that needs to be removed, can the design be simplified, is everything expressed clearly etc. Our tests give us a safety net that allows us to simplify our code with confidence. If we have taken too much away they will let us know.</p>


<h2>Test-driven development in a nutshell</h2>

<p>Testing used to be an activity that few people enjoyed, because it was something you did after you finished the fun part (adding new features). Tests were often viewed as a process that while necessary, prevented the progression of 'real work'.</p>

<p>Whereas TDD is an aid to writing your best code, because it forces you to clarify your intentions by writing tests before you write any code. A test-first approach also gives us access to rapid feedback that let's us know if our design ideas actually work in practice, because those ideas are verified or not at every stage of the build.</p>

<p>There are three main stages of TDD:</p>

<ol>
  <li>Write a failing unit test before you write any code</li>
  <li>Make the test pass in the simplest way you can (obvious implementation)</li>
  <li>Refactor (remove duplication with the rule of three, simplify, etc)</li>
</ol>

<h3>Refactoring</h3>

<p>Refactoring is where you improve code by changing it's structure without changing it's behaviour. This is similar to editing an article, where you change the way you phrase things without changing the underlying message that you are trying to convey.</p>

<p>Changes that do not modify the codes behaviour is called a 'transformation' within the refactoring approach. There are many different transformations you can use when refactoring. Each of them are small, safe steps that can be verified with your tests to make sure that everything still works after each of them have been implemented.</p>

<p>Refactoring is considered to be a 'microtechnique' that allows you to make a series of tiny improvements. If you do this consistently, then your system will be significantly improved. This is great advice for adopting any great habit too, tiny steps lead to massive change, almost without realising it.</p>

<h3>Benefits of TDD</h3>

<ul>
  <li>Makes us clarify our intentions instead of just winging it.</li>
  <li>Encourages you to write components that can be tested in isolation (reduce dependencies - loosly coupled)</li>
  <li>The tests read like a list of specifications. It is a live snapshot of everything the system can do. Inside each test is the code that represents how you do the thing you are testing for in the real system.</li>
  <li>You'll have complete regression coverage, so you can make changes and knowthe moment something is broken. This makes things easy to undo, unlike discovering bugs later in the process.</li>
  <li>Testing also lets us know when we have done enough, which happens when we have finished testing that a feature behaves in the way that we want it to in as many situations as we can anticipate. The tests will let us know when we encounter an unexpected situation that we didn't account for.</li>
</ul>

<h2>The bigger picture</h2>

<p>A critical benefit of the TDD process is that it makes us write tests for code that we actually need (write a failing test first). This is an advantage over the dominant testing approach before TDD was introduced, which is where you would write unit tests for the classes in your application, usually well after the original code for those classes were written.</p>

<h2>Testing end-to-end</h2>

<h2>External and internal quality</h2>


